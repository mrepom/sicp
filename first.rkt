#lang sicp
(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
(define (list-ref x n)
  (cond ((<= n 0) (error "n lowwer 0"))
        ((null? x) (error "n out of list"))
        ((= n 1) (car x))
        (else (list-ref (cdr x) (- n 1)))))
(define (make-queque)
  (define (make-empty-queque) (cons '() '()))
  (let ((queque (make-empty-queque)))
    (define (front-ptr) (car queque))
    (define (rear-ptr) (cdr queque))
    (define (set-front-ptr! item) (set-car! queque item))
    (define (set-rear-ptr! item) (set-cdr! queque item))
    (define (empty-queque?) (null? (front-ptr)))

    (define (insert! item)
      (if (empty-queque?)
          (let ((p (cons item '())))
            (set-front-ptr! p)
            (set-rear-ptr! p)
            queque)
          (begin (set-cdr! (rear-ptr) (cons item '()))
                 (set-rear-ptr! (cdr (rear-ptr)))
                 queque)))
    (define (delete!)
      (if (empty-queque?)
          (error "DELETE! called with 
                 an empty queue" queque)
          (begin (set-front-ptr! (cdr (front-ptr)))
                 queque)))
    (define (front-queque)
      (if (empty-queque?)
          (error "DELETE! called with 
                 an empty queue" queque)
          (car (front-ptr))))
    (define (dispatch m)
      (cond ((eq? m 'insert)
             insert!)
            ((eq? m 'delete)
             (delete!))
            ((eq? m 'front)
             (front-queque))
            (else (error "Unknown Operation"))))
    dispatch))

(define (make-table)
  (let ((table (cons 'table '())))
    (define (data? t)
      (equal? (car t) 'DATA-TAG-ASDF))
    (define (data-tag value)
      (cons 'DATA-TAG-ASDF value))
    (define (assoc t key)
      (cond ((or (null? t)
                 (data? t))
             false)
            ((equal? (caar t) key) (car t))
            (else (assoc (cdr t) key))))
    (define (look-up t . arg)
      (if (null? arg)
          false
          (let ((subtable (assoc (cdr t) (car arg))))
            (if subtable
                (if (null? (cdr arg))
                    (if (data? (cdr t))
                        (cddr t)
                        false)
                    (look-up subtable (cdr arg)))
                false))))
    (define (insert! t value . keys)
      (if (null? keys)
          (set-cdr! t (data-tag value))
          (let ((subtable (assoc (cdr t) (car keys))))
            (if subtable
                (insert! subtable (cdr keys))
                ))))))
           
